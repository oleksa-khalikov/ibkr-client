/*
 * MIT License
 *
 * Copyright (c) 2015-2022 Oleksii Khalikov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program (2.4.27).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

package ua.com.gfalcon.ibkr.server.spring.api;

import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import ua.com.gfalcon.ibkr.model.AccountPnL;
import ua.com.gfalcon.ibkr.model.AlertActivation;
import ua.com.gfalcon.ibkr.model.AlertRequest;
import ua.com.gfalcon.ibkr.model.AlertResponse;
import ua.com.gfalcon.ibkr.model.AuthStatus;
import ua.com.gfalcon.ibkr.model.Body;
import ua.com.gfalcon.ibkr.model.BooleanConfirmed;
import ua.com.gfalcon.ibkr.model.BrokerageAccount;
import ua.com.gfalcon.ibkr.model.Conid;
import ua.com.gfalcon.ibkr.model.Contract;
import ua.com.gfalcon.ibkr.model.HistoryData;
import ua.com.gfalcon.ibkr.model.MarketDataCancelSingle;
import ua.com.gfalcon.ibkr.model.ModifyOrder;
import ua.com.gfalcon.ibkr.model.OrderRequest;
import ua.com.gfalcon.ibkr.model.OrderStatus;
import ua.com.gfalcon.ibkr.model.ScannerParams;
import ua.com.gfalcon.ibkr.model.ScannerParamsList;
import ua.com.gfalcon.ibkr.model.ScannerResult;
import ua.com.gfalcon.ibkr.model.SecdefInfo;
import ua.com.gfalcon.ibkr.model.SetAccount;
import ua.com.gfalcon.ibkr.model.SwitchAccount;
import ua.com.gfalcon.ibkr.model.Symbol;
import ua.com.gfalcon.ibkr.model.SystemError;
import ua.com.gfalcon.ibkr.model.Trade;

/**
 * The iserver API.
 */
@Validated
@Api(value = "iserver", description = "the iserver API")
@RequestMapping(value = "/v1/api")
public interface IserverApi {

    @ApiOperation(
            value = "Activate or deactivate an alert", nickname = "iserverAccountAccountIdAlertActivatePost",
            notes = "Please note, if alertId is 0, it will activate/deactivate all alerts", response = Object.class,
            tags = {"Alert"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = Object.class)})
    @RequestMapping(
            value = "/iserver/account/{accountId}/alert/activate", produces = {"application/json"},
            method = RequestMethod.POST)
    ResponseEntity<Object> iserverAccountAccountIdAlertActivatePost(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId,
            @ApiParam(value = "order request info", required = true) @Valid @RequestBody AlertActivation body);


    @ApiOperation(
            value = "Delete an alert", nickname = "iserverAccountAccountIdAlertAlertIdDelete",
            notes = "Please be careful, if alertId is 0, it will delete all alerts", response = Object.class,
            tags = {"Alert"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = Object.class)})
    @RequestMapping(
            value = "/iserver/account/{accountId}/alert/{alertId}", produces = {"application/json"},
            method = RequestMethod.DELETE)
    ResponseEntity<Object> iserverAccountAccountIdAlertAlertIdDelete(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId,
            @ApiParam(value = "alert id", required = true) @PathVariable("alertId") String alertId);


    @ApiOperation(
            value = "Create or modify alert", nickname = "iserverAccountAccountIdAlertPost",
            notes = "Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA"
                    + " alert ",
            response = Object.class, tags = {"Alert"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = Object.class)})
    @RequestMapping(
            value = "/iserver/account/{accountId}/alert", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<Object> iserverAccountAccountIdAlertPost(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId,
            @ApiParam(value = "alert info", required = true) @Valid @RequestBody AlertRequest body);


    @ApiOperation(
            value = "Get a list of available alerts", nickname = "iserverAccountAccountIdAlertsGet",
            notes = "The response will contain both active and inactive alerts, but it won't have MTA alert",
            response = Object.class, responseContainer = "List", tags = {"Alert"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array of objects", response = Object.class,
                    responseContainer = "List")})
    @RequestMapping(
            value = "/iserver/account/{accountId}/alerts", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<List<Object>> iserverAccountAccountIdAlertsGet(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId);


    @ApiOperation(
            value = "Cancel Order", nickname = "iserverAccountAccountIdOrderOrderIdDelete",
            notes = "Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order."
                    + " Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.",
            response = Object.class, tags = {"Order"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an object with order id, message, conid and account id",
                    response = Object.class)})
    @RequestMapping(
            value = "/iserver/account/{accountId}/order/{orderId}", produces = {"application/json"},
            method = RequestMethod.DELETE)
    ResponseEntity<Object> iserverAccountAccountIdOrderOrderIdDelete(
            @ApiParam(value = "account id, or fa group if deleting a group order", required = true) @PathVariable(
                    "accountId") String accountId, @ApiParam(
            value = "Customer order id, use /iservers/account/orders endpoint to query orderId.", required = true)
            @PathVariable("orderId") String orderId);


    @ApiOperation(
            value = "Modify Order", nickname = "iserverAccountAccountIdOrderOrderIdPost",
            notes = "Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order."
                    + " Use /iservers/account/orders endpoint to review open-order(s).",
            response = Object.class, responseContainer = "List", tags = {"Order"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array", response = Object.class, responseContainer = "List")})
    @RequestMapping(
            value = "/iserver/account/{accountId}/order/{orderId}", produces = {"application/json"},
            method = RequestMethod.POST)
    ResponseEntity<List<Object>> iserverAccountAccountIdOrderOrderIdPost(
            @ApiParam(value = "account id, or fa group if modifying a group order", required = true) @PathVariable(
                    "accountId") String accountId, @ApiParam(
            value = "Customer order id, use /iservers/account/orders endpoint to query orderId.", required = true)
            @PathVariable("orderId") String orderId,
            @ApiParam(value = "modify-order request", required = true) @Valid @RequestBody ModifyOrder body);


    @ApiOperation(
            value = "Place Order (Deprecated)", nickname = "iserverAccountAccountIdOrderPost",
            notes = "This endpoint is going to be deprecated, you can use /iserver/account/{accountId}/orders, just"
                    + " pass one order in the array, the order structure will be same. Please note here, sometimes"
                    + " this endpoint alone can't make sure you submit the order successfully, you could receive some"
                    + " questions in the response, you have to to answer them in order to submit the order"
                    + " successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions ",
            response = Object.class, responseContainer = "List", tags = {"Order"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array", response = Object.class, responseContainer = "List")})
    @RequestMapping(
            value = "/iserver/account/{accountId}/order", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<List<Object>> iserverAccountAccountIdOrderPost(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId,
            @ApiParam(value = "order request info", required = true) @Valid @RequestBody OrderRequest body);


    @ApiOperation(
            value = "Preview Order (Deprecated)", nickname = "iserverAccountAccountIdOrderWhatifPost",
            notes = "This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif,"
                    + " just pass one order in the array, the order structure will be same. This endpoint allows you"
                    + " to preview order without actually submitting the order and you can get commission information"
                    + " in the response. ",
            response = Object.class, tags = {"Order"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = Object.class)})
    @RequestMapping(
            value = "/iserver/account/{accountId}/order/whatif", produces = {"application/json"},
            method = RequestMethod.POST)
    ResponseEntity<Object> iserverAccountAccountIdOrderWhatifPost(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId,
            @ApiParam(value = "order info", required = true) @Valid @RequestBody OrderRequest body);


    @ApiOperation(
            value = "Place Orders", nickname = "iserverAccountAccountIdOrdersPost",
            notes = "When connected to an IServer Brokerage Session, this endpoint will allow you to submit orders."
                    + "  CP WEB API supports various advanced orderTypes, for additional details and examples refer to"
                    + " [IBKR Quant Blog](https://www.tradersinsight.news/category/ibkr-quant-news/programming_languages/rest-development/).   * Bracket - Attach additional opposite-side order(s) by using a single **cOID** sent with the parent and set the same value for **parentId** in each child order(s).   * Cash Quantity -  Send orders using monetary value by specifying **cashQty** instead of quantity, e.g. cashQty: 200. The endpoint /iserver/contract/rules returns list of valid orderTypes in cqtTypes.   * Currency Conversion - Convert cash from one currency to another by including **isCcyConv** = **true**. To specify the cash quantity use **fxQTY** instead of quantity, e.g. fxQTY: 100.   * Fractional - Contracts that support fractional shares can be traded by specifying **quantity** as a float, e.g. quantity: 0.001. The endpoint /iserver/contract/rules returns a list of valid orderTypes in fraqTypes.   * IB Algos - Attached user-defined settings to your trades by using any of IBKR's Algo Orders. Use the endpoint /iserver/contract/{conid}/algos to identify the available strategies for a contract.   * One-Cancels-All (OCA) - Group multiple unrelated orders by passing order request info in an array and including **isSingleGroup = true** for each order. All orders will be assigned the same oca_group_id. ",
            response = Object.class, responseContainer = "List", tags = {"Order"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array", response = Object.class, responseContainer = "List")})
    @RequestMapping(
            value = "/iserver/account/{accountId}/orders", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<List<Object>> iserverAccountAccountIdOrdersPost(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId,
            @ApiParam(value = "order request info", required = true) @Valid @RequestBody Body body);


    @ApiOperation(
            value = "Preview Orders", nickname = "iserverAccountAccountIdOrdersWhatifPost",
            notes = "This endpoint allows you to preview order without actually submitting the order and you can get"
                    + " commission information in the response. Also supports bracket orders. ",
            response = Object.class, tags = {"Order"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = Object.class)})
    @RequestMapping(
            value = "/iserver/account/{accountId}/orders/whatif", produces = {"application/json"},
            method = RequestMethod.POST)
    ResponseEntity<Object> iserverAccountAccountIdOrdersWhatifPost(
            @ApiParam(value = "account id", required = true) @PathVariable("accountId") String accountId,
            @ApiParam(value = "order info", required = true) @Valid @RequestBody Body body);


    @ApiOperation(
            value = "Get details of an alert", nickname = "iserverAccountAlertIdGet",
            notes = "Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the"
                    + " response is the alert id. ",
            response = AlertResponse.class, tags = {"Alert"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = AlertResponse.class)})
    @RequestMapping(value = "/iserver/account/alert/{id}", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<AlertResponse> iserverAccountAlertIdGet(
            @ApiParam(value = "alert id", required = true) @PathVariable("id") String id);


    @ApiOperation(
            value = "Get MTA alert", nickname = "iserverAccountMtaGet",
            notes = "Each login user only has one mobile trading assistant (MTA) alert with it's own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts. ",
            response = AlertResponse.class, tags = {"Alert"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = AlertResponse.class)})
    @RequestMapping(value = "/iserver/account/mta", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<AlertResponse> iserverAccountMtaGet();


    @ApiOperation(
            value = "Order Status", nickname = "iserverAccountOrderStatusOrderIdGet", notes = "",
            response = OrderStatus.class, tags = {"Order"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = OrderStatus.class)})
    @RequestMapping(
            value = "/iserver/account/order/status/{orderId}", produces = {"application/json"},
            method = RequestMethod.GET)
    ResponseEntity<OrderStatus> iserverAccountOrderStatusOrderIdGet(@ApiParam(
            value = "Customer order id, use /iservers/account/orders endpoint to query orderId.", required = true)
            @PathVariable("orderId") String orderId);


    @ApiOperation(
            value = "Place Orders for FA", nickname = "iserverAccountOrdersFaGroupPost",
            notes = "Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm). ",
            response = Object.class, responseContainer = "List", tags = {"Order"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array", response = Object.class, responseContainer = "List")})
    @RequestMapping(
            value = "/iserver/account/orders/{faGroup}", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<List<Object>> iserverAccountOrdersFaGroupPost(
            @ApiParam(value = "financial advisor group", required = true) @PathVariable("faGroup") String faGroup,
            @ApiParam(value = "order request info", required = true) @Valid @RequestBody OrderRequest body);


    @ApiOperation(
            value = "Live Orders", nickname = "iserverAccountOrdersGet",
            notes = "The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. ",
            response = Object.class, tags = {"Order"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "An object contains two arrays", response = Object.class)})
    @RequestMapping(value = "/iserver/account/orders", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<Object> iserverAccountOrdersGet(
            @ApiParam(value = "an array of filters") @Valid @RequestBody Body body);


    @ApiOperation(
            value = "PnL for the selected account", nickname = "iserverAccountPnlPartitionedGet",
            notes = "Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. ",
            response = Object.class, tags = {"PnL", "Account"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "An object containing account and model(s) pnl", response = Object.class)})
    @RequestMapping(
            value = "/iserver/account/pnl/partitioned", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<AccountPnL> iserverAccountPnlPartitionedGet();


    @ApiOperation(
            value = "Switch Account", nickname = "iserverAccountPost",
            notes = "If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other"
                    + " than currently selected account, then user can update the currently selected account using"
                    + " this API and then can fetch required information for the newly updated account.",
            response = SwitchAccount.class, tags = {"Account"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "an object containing updated account ID", response = SwitchAccount.class)})
    @RequestMapping(value = "/iserver/account", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<SwitchAccount> iserverAccountPost(
            @ApiParam(value = "account id", required = true) @Valid @RequestBody SetAccount body);


    @ApiOperation(
            value = "List of Trades for the selected account", nickname = "iserverAccountTradesGet",
            notes = "Returns a list of trades for the currently selected account for current day and six previous"
                    + " days. It is advised to call this endpoint once per session. ",
            response = Trade.class, responseContainer = "List", tags = {"Trades"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "An array of trades", response = Trade.class, responseContainer = "List")})
    @RequestMapping(value = "/iserver/account/trades", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<List<Trade>> iserverAccountTradesGet();


    @ApiOperation(
            value = "Brokerage Accounts", nickname = "iserverAccountsGet",
            notes = "Returns a list of accounts the user has trading access to, their respective aliases and the"
                    + " currently selected account. Note this endpoint must be called before modifying an order or"
                    + " querying open orders.",
            response = BrokerageAccount.class, tags = {"Account"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "An array of accounts", response = BrokerageAccount.class)})
    @RequestMapping(value = "/iserver/accounts", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<BrokerageAccount> iserverAccountsGet();


    @ApiOperation(
            value = "Authentication Status", nickname = "iserverAuthStatusPost",
            notes = "Current Authentication status to the Brokerage system. Market Data and Trading is not possible"
                    + " if not authenticated, e.g. authenticated shows false",
            response = AuthStatus.class, tags = {"Session"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "Authentication Status", response = AuthStatus.class)})
    @RequestMapping(value = "/iserver/auth/status", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<AuthStatus> iserverAuthStatusPost();


    @ApiOperation(
            value = "IB Algo Params", nickname = "iserverContractConidAlgosGet",
            notes = "Returns supported IB Algos for contract. Must be called a second time to query the list of"
                    + " available parameters.",
            response = Object.class, responseContainer = "List", tags = {"Contract"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array of algos", response = Object.class,
                    responseContainer = "List")})
    @RequestMapping(
            value = "/iserver/contract/{conid}/algos", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<List<Object>> iserverContractConidAlgosGet(
            @ApiParam(value = "IBKR contract identifier", required = true) @PathVariable("conid") String conid,
            @ApiParam(value = "List of algo ids delimited by \";\" to filter by. Max of 8 algos ids can be specified.")
            @Valid @RequestParam(
                    value = "algos", required = false) String algos,
            @ApiParam(value = "Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.") @Valid
            @RequestParam(
                    value = "addDescription", required = false) String addDescription,
            @ApiParam(value = "Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.") @Valid
            @RequestParam(
                    value = "addParams", required = false) String addParams);


    @ApiOperation(
            value = "Info and Rules", nickname = "iserverContractConidInfoAndRulesGet",
            notes = "Returns both contract info and rules from a single endpoint. For only contract rules, use the"
                    + " endpoint /iserver/contract/rules. For only contract info, use the endpoint"
                    + " /iserver/contract/{conid}/info.  ",
            response = Object.class, tags = {"Contract"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an array", response = Object.class)})
    @RequestMapping(
            value = "/iserver/contract/{conid}/info-and-rules", produces = {"application/json"},
            method = RequestMethod.GET)
    ResponseEntity<Object> iserverContractConidInfoAndRulesGet(
            @ApiParam(value = "IBKR contract identifier", required = true) @PathVariable("conid") String conid,
            @NotNull @ApiParam(
                    value = "Side of the market rules apply too. Set to **true** for Buy Orders, set to **false** for"
                            + " Sell Orders",
                    required = true) @Valid @RequestParam(value = "isBuy", required = true) Boolean isBuy);


    @ApiOperation(
            value = "Contract Details", nickname = "iserverContractConidInfoGet",
            notes = "Using the Contract Identifier get contract info. You can use this to prefill your order before"
                    + " you submit an order",
            response = Contract.class, tags = {"Contract"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an object", response = Contract.class)})
    @RequestMapping(
            value = "/iserver/contract/{conid}/info", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<Contract> iserverContractConidInfoGet(
            @ApiParam(value = "contract id", required = true) @PathVariable("conid") String conid);


    @ApiOperation(
            value = "Contract Rules", nickname = "iserverContractRulesPost",
            notes = "Returns trading related rules for a specific contract and side. For both contract info and rules"
                    + " use the endpoint /iserver/contract/{conid}/info-and-rules.",
            response = Object.class, tags = {"Contract"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "returns an array", response = Object.class)})
    @RequestMapping(value = "/iserver/contract/rules", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<Object> iserverContractRulesPost(
            @ApiParam(value = "", required = true) @Valid @RequestBody Conid conid);


    @ApiOperation(
            value = "Market Data Cancel (Single)", nickname = "iserverMarketdataConidUnsubscribeGet",
            notes = "Cancel market data for given conid. To cancel all market data request(s),"
                    + " see /iserver/marketdata/unsubscribeall. ",
            response = MarketDataCancelSingle.class, tags = {"Market Data"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "confirms market data for conid is cancelled",
                    response = MarketDataCancelSingle.class), @ApiResponse(code = 500, message = "cancel failed")})
    @RequestMapping(
            value = "/iserver/marketdata/{conid}/unsubscribe", produces = {"application/json"},
            method = RequestMethod.GET)
    ResponseEntity<MarketDataCancelSingle> iserverMarketdataConidUnsubscribeGet(
            @ApiParam(value = "contract id", required = true) @PathVariable("conid") String conid);


    @ApiOperation(
            value = "Market Data History", nickname = "iserverMarketdataHistoryGet",
            notes = "Get historical market Data for given conid, length of data is controlled by 'period' and 'bar'."
                    + " Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w"
                    + " returns 52 data points (Max of 1000 data points supported)."
                    + " **Note**: There's a limit of 5 concurrent requests."
                    + " Excessive requests will return a 'Too many requests' status 429 response. ",
            response = HistoryData.class, tags = {"Market Data"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "Returns an object", response = HistoryData.class), @ApiResponse(
                    code = 429, message = "Too many requests", response = Object.class), @ApiResponse(
                    code = 500, message = "System Error", response = SystemError.class)})
    @RequestMapping(value = "/iserver/marketdata/history", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<HistoryData> iserverMarketdataHistoryGet(
            @NotNull @ApiParam(value = "contract id", required = true) @Valid @RequestParam(
                    value = "conid", required = true) String conid, @NotNull @ApiParam(
            value = "available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y",
            required = true) @Valid @RequestParam(value = "period", required = true) String period, @ApiParam(
            value = "Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to"
                    + " primary exchange of the conid.")
            @Valid @RequestParam(
            value = "exchange", required = false) String exchange, @ApiParam(
            value = "possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m")
            @Valid @RequestParam(
            value = "bar", required = false) String bar, @ApiParam(
            value = "For contracts that support it, will determine if historical data includes outside of regular"
                    + " trading hours.")
            @Valid @RequestParam(
            value = "outsideRth", required = false) Boolean outsideRth);


    @ApiOperation(
            value = "Market Data", nickname = "iserverMarketdataSnapshotGet",
            notes = "Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first.  If you call any other endpoints that relays back market data for the same contract, such as /iserver/contract/rules then you must query market data again to ensure all fields are properly returned.  First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. ",
            response = Object.class, responseContainer = "List", tags = {"Market Data"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "Returns an array of objects", response = Object.class,
                    responseContainer = "List"), @ApiResponse(
                    code = 400, message = "sent when accounts are not queried before sending this request",
                    response = Object.class)})
    @RequestMapping(value = "/iserver/marketdata/snapshot", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<List<Object>> iserverMarketdataSnapshotGet(@NotNull @ApiParam(
            value = "list of conids separated by comma", required = true) @Valid
            @RequestParam(value = "conids", required = true) String conids,
            @ApiParam(value = "time period since which updates are required. uses epoch time with milliseconds.") @Valid
            @RequestParam(
                    value = "since", required = false) Integer since,
            @ApiParam(value = "list of fields separated by comma") @Valid @RequestParam(
                    value = "fields", required = false) String fields);


    @ApiOperation(
            value = "Market Data Cancel (All)", nickname = "iserverMarketdataUnsubscribeallGet",
            notes = "Cancel all market data request(s). To cancel market data for given conid,"
                    + " see /iserver/marketdata/{conid}/unsubscribe. ",
            response = BooleanConfirmed.class, tags = {"Market Data"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "confirms market data is cancelled", response = BooleanConfirmed.class)})
    @RequestMapping(
            value = "/iserver/marketdata/unsubscribeall", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<BooleanConfirmed> iserverMarketdataUnsubscribeallGet();


    @ApiOperation(
            value = "Tries to re-authenticate to Brokerage", nickname = "iserverReauthenticatePost",
            notes = "When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage"
                    + " system as long as there is a valid SSO session, see /sso/validate. ",
            response = AuthStatus.class, tags = {"Session"})
    @ApiResponses(value = {@ApiResponse(code = 200, message = "Authentication Status", response = AuthStatus.class)})
    @RequestMapping(value = "/iserver/reauthenticate", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<AuthStatus> iserverReauthenticatePost();


    @ApiOperation(
            value = "Place Order Reply", nickname = "iserverReplyReplyidPost",
            notes = "Reply to questions when placing orders and submit orders", response = Object.class,
            responseContainer = "List", tags = {"Order"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "Order is submitted successfully, returns an array contains one object",
                    response = Object.class, responseContainer = "List"), @ApiResponse(
                    code = 400, message = "When you send \"confirmed-false\" in the request, you will receive this",
                    response = Object.class)})
    @RequestMapping(value = "/iserver/reply/{replyid}", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<List<Object>> iserverReplyReplyidPost(@ApiParam(
            value = "Please use the \"id\" from the response of \"Place Order\" endpoint", required = true)
            @PathVariable("replyid") String replyid,
            @ApiParam(value = "Answer to question", required = true) @Valid @RequestBody Body body);


    @ApiOperation(
            value = "Scanner Parameters", nickname = "iserverScannerParamsGet",
            notes = "Returns an object contains four lists contain all parameters for scanners",
            response = ScannerParamsList.class, tags = {"Scanner"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "An object contains lists", response = ScannerParamsList.class)})
    @RequestMapping(value = "/iserver/scanner/params", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<ScannerParamsList> iserverScannerParamsGet();


    @ApiOperation(
            value = "run scanner to get a list of contracts", nickname = "iserverScannerRunPost", notes = "",
            response = ScannerResult.class, responseContainer = "List", tags = {"Scanner"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array", response = ScannerResult.class,
                    responseContainer = "List")})
    @RequestMapping(value = "/iserver/scanner/run", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<List<ScannerResult>> iserverScannerRunPost(
            @ApiParam(value = "scanner-params request", required = true) @Valid @RequestBody ScannerParams body);


    @ApiOperation(
            value = "Secdef Info", nickname = "iserverSecdefInfoGet",
            notes = "Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the"
                    + " strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint."
                    + " Must call /secdef/search for the underlying contract first.",
            response = SecdefInfo.class, responseContainer = "List", tags = {"Contract"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array of objects", response = SecdefInfo.class,
                    responseContainer = "List"), @ApiResponse(
                    code = 500, message = "error while processing the request", response = Object.class)})
    @RequestMapping(value = "/iserver/secdef/info", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<List<SecdefInfo>> iserverSecdefInfoGet(
            @NotNull @ApiParam(value = "underlying contract id", required = true) @Valid @RequestParam(
                    value = "conid", required = true) String conid,
            @NotNull @ApiParam(value = "FUT/OPT/WAR/CASH/CFD", required = true) @Valid @RequestParam(
                    value = "sectype", required = true) String sectype,
            @ApiParam(value = "contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00") @Valid
            @RequestParam(
                    value = "month", required = false) String month,
            @ApiParam(value = "optional, default is SMART") @Valid @RequestParam(
                    value = "exchange", required = false) String exchange,
            @ApiParam(value = "optional, only required for OPT/WAR") @Valid @RequestParam(
                    value = "strike", required = false) String strike,
            @ApiParam(value = "C for call, P for put") @Valid @RequestParam(
                    value = "right", required = false) String right);


    @ApiOperation(
            value = "Search by Symbol or Name", nickname = "iserverSecdefSearchPost",
            notes = "Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This"
                    + " endpoint must be called before using /secdef/info. If company name is specified will only"
                    + " receive limited response: conid, companyName, companyHeader and symbol. ",
            response = Object.class, responseContainer = "List", tags = {"Contract"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an array of results", response = Object.class,
                    responseContainer = "List"), @ApiResponse(
                    code = 500, message = "error while processing the request", response = Object.class)})
    @RequestMapping(value = "/iserver/secdef/search", produces = {"application/json"}, method = RequestMethod.POST)
    ResponseEntity<List<Object>> iserverSecdefSearchPost(@ApiParam(
            value = "Symbol or Company Name to be searched", required = true) @Valid @RequestBody Symbol symbol);


    @ApiOperation(
            value = "Search Strikes", nickname = "iserverSecdefStrikesGet",
            notes = "Query strikes for Options/Warrants. For the conid of the underlying contract, available contract"
                    + " months and exchanges use \"/iserver/secdef/search\"",
            response = Object.class, tags = {"Contract"})
    @ApiResponses(
            value = {@ApiResponse(
                    code = 200, message = "returns an object contains call/put strike prices",
                    response = Object.class), @ApiResponse(
                    code = 500, message = "error while processing the request", response = Object.class)})
    @RequestMapping(value = "/iserver/secdef/strikes", produces = {"application/json"}, method = RequestMethod.GET)
    ResponseEntity<Object> iserverSecdefStrikesGet(
            @NotNull @ApiParam(value = "contract id of the underlying contract", required = true) @Valid @RequestParam(
                    value = "conid", required = true) String conid,
            @NotNull @ApiParam(value = "OPT/WAR", required = true) @Valid @RequestParam(
                    value = "sectype", required = true) String sectype,
            @NotNull @ApiParam(value = "contract month", required = true) @Valid @RequestParam(
                    value = "month", required = true) String month,
            @ApiParam(value = "optional, default is SMART") @Valid @RequestParam(
                    value = "exchange", required = false) String exchange);

}
